package errkit

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/durationpb"
)

type ErrWrapper interface {
	error
	// Get the error response marshalled as JSON. This should be formatted according to
	// RFC 9475: https://datatracker.ietf.org/doc/html/rfc9457#name-the-problem-details-json-ob
	//
	// Will respond with an error if it fails to marshal the struct into JSON.
	JsonRes(opts *Options) ([]byte, error)

	// Implementing the Unwrap functionality allows usage of wrapped error checks with
	// the `errors` pkg. More information on https://pkg.go.dev/errors
	//
	// Example usage on an error:
	//   if errors.Is(err, errkit.ErrNotFound) // checks if the error is matching the given type
	Unwrap() error
}

type ErrGRPC interface {
	ErrWrapper
	// Responding with the gRPC status code for this error with its details
	GRPCStatus() *status.Status
}

// Base error response contents according to RFC 9475 to help identifying the original cause
// of a problem.
//
// This response will be used as JSON response to send back to the consumer.
//
// This struct should further be extended by additional information specific to an error type.
type ErrRes struct {
	// The "type" member is a JSON string containing a URI reference that identifies the problem type.
	// https://datatracker.ietf.org/doc/html/rfc9457#name-type
	Type string `json:"type"`

	// The "status" member is a JSON number indicating the HTTP status code generated by the origin
	// server for this occurrence of the problem.
	// https://datatracker.ietf.org/doc/html/rfc9457#name-status
	Status int `json:"status"`

	// The "title" member is a JSON string containing a short, human-readable summary of the problem type.
	// https://datatracker.ietf.org/doc/html/rfc9457#name-title
	Title string `json:"title"`

	// The "detail" member is a JSON string containing a human-readable explanation specific to this
	// occurrence of the problem.
	// https://datatracker.ietf.org/doc/html/rfc9457#name-detail
	Detail string `json:"detail"`

	// The "instance" member is a JSON string containing a URI reference that identifies the specific
	// occurrence of the problem.
	// https://datatracker.ietf.org/doc/html/rfc9457#name-instance
	Instance string `json:"instance"`
}

// Creates a string with the error message prefixed by a colon and space,
// if there is an error. Otherwise empty string.
func BuildWrappedErrMsg(err error) string {
	prefixedErr := ""
	if err != nil {
		prefixedErr = fmt.Sprintf(": %s", err.Error())
	}
	return prefixedErr
}

// Creates a string with the message prefixed by a colon and space to display on printing an error,
// if it's not an empty msg string.
func BuildWrappedMsg(msg string) string {
	prefixedMsg := ""
	if len(msg) > 0 {
		prefixedMsg = fmt.Sprintf(": %s", msg)
	}
	return prefixedMsg
}

// Create an Unknown error.
//
// This should preferably never be used and is therefore not exported.
// It should only be used as fallback, if the type of error cannot be determined.
//
// Example error message:
//
//	"unknown error"
//	HTTP: 500 Internal Server Error
//	gRPC: 2 UNKNOWN
type errUnknown struct {
	// Wrapped error
	Err error
}

func (e *errUnknown) StatusHTTP() int { return http.StatusBadRequest }
func (e *errUnknown) Unwrap() error   { return e.Err }
func (e *errUnknown) JsonRes(opts *Options) ([]byte, error) {
	res := ErrRes{
		Type:  "https://errors.ekolivs.se/unknown",
		Title: "An unknown error occured.",
		// TODO: build logic for responses that should not contain the error in output to reduce the
		// information transparency with consumers.
		Detail:   e.Error(),
		Status:   e.StatusHTTP(),
		Instance: opts.Instance,
	}
	return json.Marshal(res)
}
func (e *errUnknown) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.Unknown, e.Error())
	return st
}
func (e *errUnknown) Error() string {
	return fmt.Sprintf("unknown error%s", BuildWrappedErrMsg(e.Err))
}

// Create a BadRequest error.
//
// The server cannot or will not process the request due to something that is perceived
// to be a client error (e.g., malformed request syntax, invalid request message framing,
// or deceptive request routing).
//
// Examples to create error:
//
//	&ErrBadRequest{}
//	&ErrBadRequest{Err: err}
//
// Example error message:
//
//	"invalid request"
//	HTTP: 400 Bad Request
//	gRPC: 3 INVALID_ARGUMENT
type ErrBadRequest struct {
	// (optional) Wrapped error
	Err error
}

type errBadRequestRes struct {
	ErrRes
}

func (e *ErrBadRequest) StatusHTTP() int { return http.StatusBadRequest }
func (e *ErrBadRequest) Unwrap() error   { return e.Err }
func (e *ErrBadRequest) JsonRes(opts *Options) ([]byte, error) {
	res := errBadRequestRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/bad-request",
			Title: "Request is invalid.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrBadRequest) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.InvalidArgument, e.Error())
	return st
}
func (e *ErrBadRequest) Error() string {
	return fmt.Sprintf("invalid request%s", BuildWrappedErrMsg(e.Err))
}

// Create an Unmarshal error.
//
// Failed to unmarshal request data into given data structure.
//
// Examples to create error:
//
//	&ErrUnmarshal{DataName: "product request", Err: err}
//	&ErrUnmarshal{DataName: "product request", Err: err}
//
// Example error message:
//
//	"unable to unmarshal product request"
//	HTTP: 400 Bad Request
//	gRPC: 3 INVALID_ARGUMENT
type ErrUnmarshal struct {
	// Wrapped error
	Err error
	// Name of input data to unmarshal.
	DataName string
}

type errUnmarshalRes struct {
	ErrRes
}

func (e *ErrUnmarshal) StatusHTTP() int { return http.StatusBadRequest }
func (e *ErrUnmarshal) Unwrap() error   { return e.Err }
func (e *ErrUnmarshal) JsonRes(opts *Options) ([]byte, error) {
	res := errUnmarshalRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/unmarshal",
			Title: "Request data invalid.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrUnmarshal) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.InvalidArgument, e.Error())
	st, err := st.WithDetails(&UnmarshalDetails{DataName: e.DataName})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrUnmarshal) Error() string {
	return fmt.Sprintf("unable to unmarshal %s%s", e.DataName, BuildWrappedErrMsg(e.Err))
}

// Create a Unauthenticated error.
//
// The request does not have valid authentication credentials for the operation.
//
// Examples to create error:
//
//	&ErrUnauthenticated{}
//	&ErrUnauthenticated{Err: err}
//
// Example error message:
//
//	"no valid authentication credentials"
//	HTTP: 401 Unauthorized
//	gRPC: 16 UNAUTHENTICATED
type ErrUnauthenticated struct {
	// (optional) Wrapped error
	Err error
}

type errUnauthenticatedRes struct {
	ErrRes
}

func (e *ErrUnauthenticated) StatusHTTP() int { return http.StatusUnauthorized }
func (e *ErrUnauthenticated) Unwrap() error   { return e.Err }
func (e *ErrUnauthenticated) JsonRes(opts *Options) ([]byte, error) {
	res := errUnauthenticatedRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/unauthenticated",
			Title: "You are not authenticated.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrUnauthenticated) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.Unauthenticated, e.Error())
	return st
}
func (e *ErrUnauthenticated) Error() string {
	return fmt.Sprintf("no valid authentication credentials%s", BuildWrappedErrMsg(e.Err))
}

// Create a PermissionDenied error.
//
// The caller does not have permission to execute the specified operation.
//
// Examples to create error:
//
//	&ErrPermissionDenied{Username: "john.doe"}
//	&ErrPermissionDenied{Username: "john.doe", Msg: "no permissions on this location"}
//
// Example error message:
//
//	"permission denied for john.doe: no permissions on this location"
//	HTTP: 403 Forbidden
//	gRPC: 7 PERMISSION_DENIED
type ErrPermissionDenied struct {
	// (optional) Wrapped error
	Err error
	// (optional) Custom message why the access has been denied
	Msg string
	// Name of user that was denied access
	Username string
}

type errPermissionDeniedRes struct {
	ErrRes
}

func (e *ErrPermissionDenied) StatusHTTP() int { return http.StatusForbidden }
func (e *ErrPermissionDenied) Unwrap() error   { return e.Err }
func (e *ErrPermissionDenied) JsonRes(opts *Options) ([]byte, error) {
	res := errPermissionDeniedRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/permission-denied",
			Title: "You do not have permission.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrPermissionDenied) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.PermissionDenied, e.Error())
	st, err := st.WithDetails(&PermissionDeniedDetails{Msg: e.Msg, Username: e.Username})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrPermissionDenied) Error() string {
	return fmt.Sprintf("permission denied for %s%s%s", e.Username, BuildWrappedMsg(e.Msg), BuildWrappedErrMsg(e.Err))
}

// Create a NotFound error.
//
// Some requested entity (e.g., file or directory) was not found.
//
// Examples to create error:
//
//	&ErrNotFound{DataName: "product", Query: "12345"}
//	&ErrNotFound{DataName: "product", Query: "12345", Err: err}
//	&ErrNotFound{DataName: "product", Query: "12345", Err: err}
//
// Example error message:
//
//	"product 12345 could not be fetched"
//	HTTP: 404 Not Found
//	gRPC: 5 NOT_FOUND
type ErrNotFound struct {
	// (optional) Wrapped error
	Err error
	// Name of the data type that could not be found e.g. `product`.
	DataName string
	// Request query that was used to try fetching the data e.g. `UNIQUE_PRODUCT_ID`
	Query string
}

type errNotFoundRes struct {
	ErrRes
}

func (e *ErrNotFound) StatusHTTP() int { return http.StatusNotFound }
func (e *ErrNotFound) Unwrap() error   { return e.Err }
func (e *ErrNotFound) JsonRes(opts *Options) ([]byte, error) {
	res := errNotFoundRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/not-found",
			Title: "Data not found.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: fmt.Sprintf("%s/%s", opts.Instance, e.Query),
		},
	}
	return json.Marshal(res)
}
func (e *ErrNotFound) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.NotFound, e.Error())
	st, err := st.WithDetails(&NotFoundDetails{DataName: e.DataName, Query: e.Query})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrNotFound) Error() string {
	return fmt.Sprintf("%s %s could not be fetched%s", e.DataName, e.Query, BuildWrappedErrMsg(e.Err))
}

// Create an Internal error.
//
// The server has encountered a situation it does not know how to handle.
//
// Examples to create error:
//
//	&ErrInternal{Err: err}
//
// Example error message:
//
//	"internal server error"
//	HTTP: 500 Internal Server Error
//	gRPC: 13 INTERNAL
type ErrInternal struct {
	// Wrapped error
	Err error
	// (optional) Custom message about error
	Msg string
}

type errInternalRes struct {
	ErrRes
}

func (e *ErrInternal) StatusHTTP() int { return http.StatusInternalServerError }
func (e *ErrInternal) Unwrap() error   { return e.Err }
func (e *ErrInternal) JsonRes(opts *Options) ([]byte, error) {
	res := errInternalRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/internal",
			Title: "An internal error occured.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrInternal) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.Internal, e.Error())
	st, err := st.WithDetails(&InternalDetails{Msg: e.Msg})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrInternal) Error() string {
	return fmt.Sprintf("internal server error%s%s", BuildWrappedMsg(e.Msg), BuildWrappedErrMsg(e.Err))
}

// Create a Marshal error.
//
// Failed to encode data into a []byte.
//
// Examples to create error:
//
//	&ErrMarshal{Err: err}
//
// Example error message:
//
//	"failed to marshal json"
//	HTTP: 500 Internal Server Error
//	gRPC: 13 INTERNAL
type ErrMarshal struct {
	// Wrapped error
	Err error
}

type errMarshalRes struct {
	ErrRes
}

func (e *ErrMarshal) StatusHTTP() int { return http.StatusInternalServerError }
func (e *ErrMarshal) Unwrap() error   { return e.Err }
func (e *ErrMarshal) JsonRes(opts *Options) ([]byte, error) {
	res := errMarshalRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/marshal",
			Title: "Failed to serve response.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrMarshal) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.Internal, e.Error())
	st, err := st.WithDetails(&MarshalDetails{})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrMarshal) Error() string {
	return fmt.Sprintf("failed to marshal json%s", BuildWrappedErrMsg(e.Err))
}

// Create a ReadFile error.
//
// Failed to read in a file.
//
// Examples to create error:
//
//	&ErrReadFile{Err: err}
//
// Example error message:
//
//	"failed to read file"
//	HTTP: 500 Internal Server Error
//	gRPC: 13 INTERNAL
type ErrReadFile struct {
	// Wrapped error
	Err error
	// (optional) Path to fail that was attempted to read
	FilePath string
}

type errReadFileRes struct {
	ErrRes
}

func (e *ErrReadFile) StatusHTTP() int { return http.StatusInternalServerError }
func (e *ErrReadFile) Unwrap() error   { return e.Err }
func (e *ErrReadFile) JsonRes(opts *Options) ([]byte, error) {
	res := errReadFileRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/read-file",
			Title: "Failed to read a file.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrReadFile) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.Internal, e.Error())
	st, err := st.WithDetails(&ReadFileDetails{FilePath: e.FilePath})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrReadFile) Error() string {
	return fmt.Sprintf("failed to read file at %s%s", e.FilePath, BuildWrappedErrMsg(e.Err))
}

// Create a conversion error.
//
// Failed to cast data into given data struct.
//
// Examples to create error:
//
//	&ErrConversion{Err: err}
//
// Example error message:
//
//	"failed to Conversion json"
//	HTTP: 500 Internal Server Error
//	gRPC: 13 INTERNAL
type ErrConversion struct {
	// (optional) Wrapped error
	Err error
	// Target struct type that could not be converted to
	Struct string
}

type errConversionRes struct {
	ErrRes
}

func (e *ErrConversion) StatusHTTP() int { return http.StatusInternalServerError }
func (e *ErrConversion) Unwrap() error   { return e.Err }
func (e *ErrConversion) JsonRes(opts *Options) ([]byte, error) {
	res := errConversionRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/conversion",
			Title: "Failed internal conversion.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrConversion) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.Internal, e.Error())
	st, err := st.WithDetails(&ConversionDetails{Struct: e.Struct})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrConversion) Error() string {
	return fmt.Sprintf("failed to convert to struct %s%s", e.Struct, BuildWrappedErrMsg(e.Err))
}

// Create an Unavailable error.
//
// The service is currently unavailable. This is most likely a transient condition,
// which can be corrected by retrying with a backoff.
//
// Examples to create error:
//
//	&ErrUnavailable{}
//	&ErrUnavailable{Err: err}
//
// Example error message:
//
//	"service is not reachable"
//	HTTP: 503 Service Unavailable
//	gRPC: 14 UNAVAILABLE
type ErrUnavailable struct {
	// (optional) Wrapped error
	Err error
	// (optional) Custom message about error
	Msg string
}

type errUnavailableRes struct {
	ErrRes
}

func (e *ErrUnavailable) StatusHTTP() int { return http.StatusServiceUnavailable }
func (e *ErrUnavailable) Unwrap() error   { return e.Err }
func (e *ErrUnavailable) JsonRes(opts *Options) ([]byte, error) {
	res := errUnavailableRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/unavailable",
			Title: "A service is unavailable.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrUnavailable) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.Unavailable, e.Error())
	st, err := st.WithDetails(&UnavailableDetails{Msg: e.Msg})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrUnavailable) Error() string {
	return fmt.Sprintf("service is not reachable%s%s", BuildWrappedMsg(e.Msg), BuildWrappedErrMsg(e.Err))
}

// Create a Timeout error.
//
// The deadline expired before the operation could complete.
//
// Examples to create error:
//
//	&ErrTimeout{}
//	&ErrTimeout{Err: err}
//
// Example error message:
//
//	"timeout after 7s"
//	HTTP: 504 Gateway Timeout
//	gRPC: 4 DEADLINE_EXCEEDED
type ErrTimeout struct {
	// (optional) Wrapped error
	Err error
	// Timeout which the request operation exceeded.
	Timeout *durationpb.Duration
}

type errTimeoutRes struct {
	ErrRes
}

func (e *ErrTimeout) StatusHTTP() int { return http.StatusGatewayTimeout }
func (e *ErrTimeout) Unwrap() error   { return e.Err }
func (e *ErrTimeout) JsonRes(opts *Options) ([]byte, error) {
	res := errTimeoutRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/timeout",
			Title: "Request timed out.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
	}
	return json.Marshal(res)
}
func (e *ErrTimeout) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.DeadlineExceeded, e.Error())
	st, err := st.WithDetails(&TimeoutDetails{Timeout: e.Timeout})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrTimeout) Error() string {
	if e.Timeout == nil {
		return fmt.Sprintf("timeout: %s", BuildWrappedErrMsg(e.Err))
	} else {
		return fmt.Sprintf("timeout after %s%s", e.Timeout.String(), BuildWrappedErrMsg(e.Err))
	}
}

// Create an error on a failed validation.
//
// The input data contains malformed or invalid data on certain fields
// that did not pass the validation checks on the server.
//
// Examples to create error:
//
//	&ErrValidationFailed{}
//	&ErrValidationFailed{Err: err}
//
// Example error message:
//
//	"validation failed"
//	HTTP: 400 Bad Request
//	gRPC: 3 INVALID_ARGUMENT
type ErrValidationFailed struct {
	// (optional) Wrapped error
	Err error
	// List of validations that failed
	Validations []*VFDets_Val
}

type errValidationFailedRes struct {
	ErrRes
	Validations []*VFDets_Val `json:"validations"`
}

func (e *ErrValidationFailed) StatusHTTP() int { return http.StatusBadRequest }
func (e *ErrValidationFailed) Unwrap() error   { return e.Err }
func (e *ErrValidationFailed) JsonRes(opts *Options) ([]byte, error) {
	res := errValidationFailedRes{
		ErrRes: ErrRes{
			Type:  "https://errors.ekolivs.se/validation-failed",
			Title: "Validation failed.",
			// TODO: build logic for responses that should not contain the error in output to reduce the
			// information transparency with consumers.
			Detail:   e.Error(),
			Status:   e.StatusHTTP(),
			Instance: opts.Instance,
		},
		Validations: e.Validations,
	}
	return json.Marshal(res)
}
func (e *ErrValidationFailed) GRPCStatus() *status.Status {
	// TODO: build logic for responses that should not contain the error in output to reduce the
	// information transparency with consumers.
	st := status.New(codes.InvalidArgument, e.Error())
	st, err := st.WithDetails(&VFDets{Validations: e.Validations})
	if err != nil {
		log.Printf("Unexpected error attaching metadata: %v\n", err)
	}
	return st
}
func (e *ErrValidationFailed) Error() string {
	details := ""
	for i, v := range e.Validations {
		if i > 0 {
			details = details + ", "
		}
		details = details + v.Detail
	}
	return fmt.Sprintf("%s%s", details, BuildWrappedErrMsg(e.Err))
}
